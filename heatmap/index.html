<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Heatmap in D3 v5</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <link rel="stylesheet" href="heatmap.css">
</head>
<body>
<div id="heatmap"></div>
<script>
//  http://bl.ocks.org/mbostock/3202354
let margin = {top: 20, right: 90, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

let parseDate = d3.timeParse("%Y-%m-%d"),
    formatDate = d3.timeFormat("%b %d");

let x = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    z = d3.scaleLinear().range(["white", "steelblue"]);

// The size of the buckets in the CSV data file.
// This could be inferred from the data if it weren't sparse.
let xStep = 864e5,
    yStep = 100;

let svg = d3.select("#heatmap").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", `translate(${margin.left},${margin.top})`)

async function makeHeatmap(filename) {
  const buckets = await d3.csv(filename, type)

  // Compute the scale domains.
  x.domain(d3.extent(buckets, d => d.date));
  y.domain(d3.extent(buckets, d => d.bucket));
  z.domain([0, d3.max(buckets, d => d.count)]);

  // Extend the x- and y-domain to fit the last bucket.
  // For example, the y-bucket 3200 corresponds to values [3200, 3300].
  x.domain([x.domain()[0], +x.domain()[1] + xStep]);
  y.domain([y.domain()[0], y.domain()[1] + yStep]);

  // Display the tiles for each non-zero bucket.
  // See http://bl.ocks.org/3074470 for an alternative implementation.
  svg.selectAll(".tile")
    .data(buckets)
    .join("rect")
      .attr("class", "tile")
      .attr("x", d => x(d.date))
      .attr("y", d => y(d.bucket + yStep))
      .attr("width", x(xStep) - x(0))
      .attr("height",  y(0) - y(yStep))
      .style("fill", d => z(d.count));

  // Add a legend for the color values.
  let legend = svg.selectAll(".legend")
    .data(z.ticks(6).slice(1).reverse())
    .join("g")
      .attr("class", "legend")
      .attr("transform", (d,i) =>  `translate(${width + 20},${20 + i * 20})`);

  legend.append("rect")
      .attr("width", 20)
      .attr("height", 20)
      .style("fill", z);

  legend.append("text")
      .attr("x", 26)
      .attr("y", 10)
      .attr("dy", ".35em")
      .text(String);

  svg.append("text")
      .attr("class", "label")
      .attr("x", width + 20)
      .attr("y", 10)
      .attr("dy", ".35em")
      .text("Count");

  // Add an x-axis with label.
  let xAxis = d3.axisBottom(x)
      .ticks(d3.timeDay)
      .tickFormat(formatDate)

  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", `translate(0,${height})`)
      .call(xAxis)

  // Add a y-axis with label.
  let yAxis = d3.axisLeft(y)
  svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
}

function type(d) {
  d.date = parseDate(d.date);
  d.bucket = +d.bucket;
  d.count = +d.count;
  return d
};

makeHeatmap('data.csv')
</script>
</body>
</html>